import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { mount } from '@vue/test-utils'
import { nextTick } from 'vue'
import CreateDesign from '@/views/CreateDesign.vue'
import { TRANSPARENT, allDMCColors } from '@/utils/dmcColors'
import { designsAPI } from '@/api/client'
import { createMockRouter, createMouseEvent, createKeyboardEvent, flushPromises } from '../helpers/testUtils'

// Mock the API client
vi.mock('@/api/client', () => ({
  designsAPI: {
    create: vi.fn()
  }
}))

describe('CreateDesign.vue', () => {
  let wrapper
  let mockRouter

  beforeEach(async () => {
    mockRouter = createMockRouter()

    wrapper = mount(CreateDesign, {
      global: {
        mocks: {
          $router: mockRouter
        }
      }
    })

    await nextTick()
  })

  afterEach(() => {
    wrapper?.unmount()
    vi.clearAllMocks()
  })

  /**
   * SECTION 1: Component Mounting & Rendering (10 tests)
   */
  describe('Component Mounting & Rendering', () => {
    it('mounts successfully', () => {
      expect(wrapper.exists()).toBe(true)
    })

    it('renders the page title', () => {
      expect(wrapper.find('h1').text()).toBe('Create New Design')
    })

    it('renders the canvas element', () => {
      const canvas = wrapper.find('canvas')
      expect(canvas.exists()).toBe(true)
    })

    it('renders settings panel', () => {
      const settingsPanel = wrapper.find('.settings-panel')
      expect(settingsPanel.exists()).toBe(true)
    })

    it('renders grid controls', () => {
      const gridControls = wrapper.find('.grid-controls')
      expect(gridControls.exists()).toBe(true)
    })

    it('renders color palette', () => {
      const palette = wrapper.find('.palette')
      expect(palette.exists()).toBe(true)
    })

    it('renders save panel', () => {
      const savePanel = wrapper.find('.save-panel')
      expect(savePanel.exists()).toBe(true)
    })

    it('renders all tool buttons', () => {
      const tools = wrapper.findAll('.setting-group .btn')
      const toolTexts = tools.map(btn => btn.text())
      expect(toolTexts.some(text => text.includes('Draw'))).toBe(true)
      expect(toolTexts.some(text => text.includes('Erase'))).toBe(true)
      expect(toolTexts.some(text => text.includes('Fill'))).toBe(true)
    })

    it('renders undo/redo buttons', () => {
      const buttons = wrapper.findAll('button')
      const buttonTexts = buttons.map(btn => btn.text())
      expect(buttonTexts.some(text => text.includes('Undo'))).toBe(true)
      expect(buttonTexts.some(text => text.includes('Redo'))).toBe(true)
    })

    it('renders all DMC colors in palette', () => {
      const paletteColors = wrapper.findAll('.palette-color')
      // 454 DMC colors + 1 TRANSPARENT
      expect(paletteColors.length).toBe(455)
    })
  })

  /**
   * SECTION 2: Grid Initialization (15 tests)
   */
  describe('Grid Initialization', () => {
    it('initializes with default grid size 30x30', () => {
      const gridInfo = wrapper.find('.grid-info')
      expect(gridInfo.text()).toBe('30Ã—30')
    })

    it('initializes grid with all transparent cells', async () => {
      // Access component instance
      const vm = wrapper.vm
      expect(vm.grid.length).toBe(30)
      expect(vm.grid[0].length).toBe(30)

      // Check all cells are transparent
      for (let y = 0; y < 30; y++) {
        for (let x = 0; x < 30; x++) {
          expect(vm.grid[y][x]).toBe(TRANSPARENT)
        }
      }
    })

    it('initializes canvas context', () => {
      const canvas = wrapper.find('canvas').element
      expect(canvas.getContext).toHaveBeenCalledWith('2d')
    })

    it('sets default color to DMC 321 Red', () => {
      const vm = wrapper.vm
      expect(vm.currentColor).toBe('#C72B3B')
    })

    it('sets default tool to draw', () => {
      const vm = wrapper.vm
      expect(vm.tool).toBe('draw')
    })

    it('initializes empty history', () => {
      const vm = wrapper.vm
      expect(vm.history.length).toBe(1) // Initial state is captured
      expect(vm.historyIndex).toBe(0)
    })

    it('initializes with empty title', () => {
      const vm = wrapper.vm
      expect(vm.title).toBe('')
    })

    it('initializes with empty description', () => {
      const vm = wrapper.vm
      expect(vm.description).toBe('')
    })

    it('initializes saving state to false', () => {
      const vm = wrapper.vm
      expect(vm.saving).toBe(false)
    })

    it('initializes with no save error', () => {
      const vm = wrapper.vm
      expect(vm.saveError).toBe(null)
    })

    it('initializes with isDrawing false', () => {
      const vm = wrapper.vm
      expect(vm.isDrawing).toBe(false)
    })

    it('sets canvas dimensions based on grid size', () => {
      const canvas = wrapper.find('canvas').element
      const vm = wrapper.vm
      const expectedWidth = vm.gridWidth * vm.cellSize
      const expectedHeight = vm.gridHeight * vm.cellSize
      expect(canvas.width).toBe(expectedWidth)
      expect(canvas.height).toBe(expectedHeight)
    })

    it('initializes grid width and height refs', () => {
      const vm = wrapper.vm
      expect(vm.gridWidth).toBe(30)
      expect(vm.gridHeight).toBe(30)
    })

    it('initializes cellSize to 15', () => {
      const vm = wrapper.vm
      expect(vm.cellSize).toBe(15)
    })

    it('captures initial state in history on mount', () => {
      const vm = wrapper.vm
      expect(vm.history.length).toBe(1)
      expect(vm.history[0]).toHaveProperty('grid')
      expect(vm.history[0]).toHaveProperty('width')
      expect(vm.history[0]).toHaveProperty('height')
    })
  })

  /**
   * SECTION 3: Drawing Tools (30 tests)
   */
  describe('Drawing Tools', () => {
    it('switches to draw tool when clicking draw button', async () => {
      const vm = wrapper.vm
      const drawBtn = wrapper.findAll('.setting-group .btn').find(btn => btn.text().includes('Draw'))

      await drawBtn.trigger('click')
      expect(vm.tool).toBe('draw')
    })

    it('switches to erase tool when clicking erase button', async () => {
      const vm = wrapper.vm
      const eraseBtn = wrapper.findAll('.setting-group .btn').find(btn => btn.text().includes('Erase'))

      await eraseBtn.trigger('click')
      expect(vm.tool).toBe('erase')
    })

    it('switches to bucket tool when clicking bucket button', async () => {
      const vm = wrapper.vm
      const bucketBtn = wrapper.findAll('.setting-group .btn').find(btn => btn.text().includes('Fill'))

      await bucketBtn.trigger('click')
      expect(vm.tool).toBe('bucket')
    })

    it('highlights active tool button', async () => {
      const drawBtn = wrapper.findAll('.setting-group .btn').find(btn => btn.text().includes('Draw'))

      await drawBtn.trigger('click')
      expect(drawBtn.classes()).toContain('active')
    })

    it('draws on canvas when clicking with draw tool', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'draw'
      vm.currentColor = '#FF0000'

      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)

      // Grid should be updated (exact cell depends on getBoundingClientRect mock)
      expect(vm.grid[0][0]).toBe('#FF0000')
    })

    it('erases cells when clicking with erase tool', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      // First draw something
      vm.grid[0][0] = '#FF0000'

      // Then erase it
      vm.tool = 'erase'
      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)

      expect(vm.grid[0][0]).toBe(TRANSPARENT)
    })

    it('sets isDrawing to true on mousedown', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)

      expect(vm.isDrawing).toBe(true)
    })

    it('sets isDrawing to false on mouseup', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.isDrawing = true
      await canvas.trigger('mouseup')

      expect(vm.isDrawing).toBe(false)
    })

    it('sets isDrawing to false on mouseleave', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.isDrawing = true
      await canvas.trigger('mouseleave')

      expect(vm.isDrawing).toBe(false)
    })

    it('allows continuous drawing on mousemove when isDrawing', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'draw'
      vm.currentColor = '#00FF00'
      vm.isDrawing = true

      const mouseMoveEvent = createMouseEvent('mousemove', { clientX: 20, clientY: 20 })
      await canvas.trigger('mousemove', mouseMoveEvent)

      // Should draw at the new position
      expect(vm.grid[1][1]).toBe('#00FF00')
    })

    it('does not draw on mousemove when not drawing', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'draw'
      vm.currentColor = '#0000FF'
      vm.isDrawing = false

      const originalGrid = JSON.parse(JSON.stringify(vm.grid))

      const mouseMoveEvent = createMouseEvent('mousemove', { clientX: 20, clientY: 20 })
      await canvas.trigger('mousemove', mouseMoveEvent)

      // Grid should remain unchanged
      expect(JSON.stringify(vm.grid)).toBe(JSON.stringify(originalGrid))
    })

    it('respects grid boundaries when drawing', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'draw'

      // Try to draw outside grid
      const mouseEvent = createMouseEvent('mousedown', { clientX: 10000, clientY: 10000 })
      await canvas.trigger('mousedown', mouseEvent)

      // Should not throw error and grid should be safe
      expect(() => vm.grid).not.toThrow()
    })

    it('changes current color when selecting from palette', async () => {
      const vm = wrapper.vm
      const paletteColors = wrapper.findAll('.palette-color')

      // Click second color (first is TRANSPARENT)
      const redColor = allDMCColors[0].hex
      await paletteColors[1].trigger('click')

      expect(vm.currentColor).toBe(redColor)
    })

    it('highlights active color in palette', async () => {
      const vm = wrapper.vm
      vm.currentColor = allDMCColors[0].hex

      await nextTick()

      const paletteColors = wrapper.findAll('.palette-color')
      // Second one should be active (first is TRANSPARENT)
      expect(paletteColors[1].classes()).toContain('active')
    })

    it('allows selecting transparent color', async () => {
      const vm = wrapper.vm
      const paletteColors = wrapper.findAll('.palette-color')

      await paletteColors[0].trigger('click')

      expect(vm.currentColor).toBe(TRANSPARENT)
    })

    it('displays color name when color is selected', async () => {
      const vm = wrapper.vm
      vm.currentColor = allDMCColors[0].hex // First DMC color

      await nextTick()

      const colorInfo = wrapper.find('.color-info')
      expect(colorInfo.text()).toContain('DMC')
    })

    it('updates color via color input', async () => {
      const vm = wrapper.vm
      const colorInput = wrapper.find('input[type="color"]')

      await colorInput.setValue('#ABCDEF')

      expect(vm.currentColor).toBe('#ABCDEF')
    })

    it('displays current color in color display square', async () => {
      const vm = wrapper.vm
      vm.currentColor = '#123456'

      await nextTick()

      const colorDisplay = wrapper.find('.color-display')
      expect(colorDisplay.attributes('style')).toContain('background: rgb(18, 52, 86)')
    })

    it('captures state before starting to draw', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')
      const initialHistoryLength = vm.history.length

      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)

      expect(vm.history.length).toBe(initialHistoryLength + 1)
    })

    it('does not capture state on each pixel during continuous drawing', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'draw'
      vm.isDrawing = true
      const historyLengthAfterStart = vm.history.length

      // Move mouse multiple times
      for (let i = 0; i < 5; i++) {
        const mouseMoveEvent = createMouseEvent('mousemove', { clientX: 10 + i, clientY: 10 + i })
        await canvas.trigger('mousemove', mouseMoveEvent)
      }

      // History should not increase during drawing
      expect(vm.history.length).toBe(historyLengthAfterStart)
    })

    it('draws with currently selected color', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'draw'
      vm.currentColor = '#AABBCC'

      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)

      expect(vm.grid[0][0]).toBe('#AABBCC')
    })

    it('clicking same cell multiple times with same color does not change it', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'draw'
      vm.currentColor = '#FF0000'
      vm.grid[0][0] = '#FF0000'

      const mouseEvent = createMouseEvent('click', { clientX: 10, clientY: 10 })
      await canvas.trigger('click', mouseEvent)

      expect(vm.grid[0][0]).toBe('#FF0000')
    })

    it('can switch colors mid-session', async () => {
      const vm = wrapper.vm

      vm.currentColor = '#FF0000'
      await nextTick()

      vm.currentColor = '#00FF00'
      await nextTick()

      expect(vm.currentColor).toBe('#00FF00')
    })

    it('can switch tools mid-session', async () => {
      const vm = wrapper.vm

      vm.tool = 'draw'
      await nextTick()

      vm.tool = 'erase'
      await nextTick()

      expect(vm.tool).toBe('erase')
    })

    it('erase tool sets cell to TRANSPARENT', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.grid[0][0] = '#FF0000'
      vm.tool = 'erase'

      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)

      expect(vm.grid[0][0]).toBe(TRANSPARENT)
    })

    it('getGridCoords calculates correct grid position', () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas').element

      // Mock event with specific coordinates
      const event = {
        clientX: 25, // Should be grid position 1 (25 / 15 = 1.66, floor = 1)
        clientY: 25
      }

      // Mock getBoundingClientRect is set to left: 0, top: 0 in setup
      const coords = vm.getGridCoords(event)
      expect(coords.x).toBe(1)
      expect(coords.y).toBe(1)
    })

    it('respects cell size when calculating grid coordinates', () => {
      const vm = wrapper.vm

      vm.cellSize = 10 // Change cell size

      const event = {
        clientX: 25,
        clientY: 25
      }

      const coords = vm.getGridCoords(event)
      expect(coords.x).toBe(2) // 25 / 10 = 2.5, floor = 2
      expect(coords.y).toBe(2)
    })

    it('handles edge case of clicking on exact grid line', () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'draw'
      vm.currentColor = '#FF0000'
      vm.cellSize = 15

      // Click exactly on cell boundary
      const mouseEvent = createMouseEvent('mousedown', { clientX: 15, clientY: 15 })
      await canvas.trigger('mousedown', mouseEvent)

      // Should place in cell (1, 1)
      expect(vm.grid[1][1]).toBe('#FF0000')
    })
  })

  /**
   * SECTION 4: Bucket Fill (20 tests)
   */
  describe('Bucket Fill Tool', () => {
    it('fills single cell when using bucket on isolated cell', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'bucket'
      vm.currentColor = '#FF0000'

      const mouseEvent = createMouseEvent('click', { clientX: 10, clientY: 10 })
      await canvas.trigger('click', mouseEvent)

      expect(vm.grid[0][0]).toBe('#FF0000')
    })

    it('fills connected region of same color', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      // Create a 3x3 region of transparent cells (already default)
      vm.tool = 'bucket'
      vm.currentColor = '#FF0000'

      const mouseEvent = createMouseEvent('click', { clientX: 22, clientY: 22 })
      await canvas.trigger('click', mouseEvent)

      // Should fill entire grid (all transparent)
      for (let y = 0; y < vm.gridHeight; y++) {
        for (let x = 0; x < vm.gridWidth; x++) {
          expect(vm.grid[y][x]).toBe('#FF0000')
        }
      }
    })

    it('does not fill across different colors', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      // Create a barrier
      vm.grid[1][0] = '#0000FF'
      vm.grid[1][1] = '#0000FF'
      vm.grid[1][2] = '#0000FF'

      vm.tool = 'bucket'
      vm.currentColor = '#FF0000'

      // Click above the barrier
      const mouseEvent = createMouseEvent('click', { clientX: 10, clientY: 10 })
      await canvas.trigger('click', mouseEvent)

      // Cells above barrier should be filled
      expect(vm.grid[0][0]).toBe('#FF0000')

      // Cells below barrier should remain transparent
      expect(vm.grid[2][0]).toBe(TRANSPARENT)
    })

    it('handles clicking on cell with same color as replacement', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.grid[0][0] = '#FF0000'
      vm.tool = 'bucket'
      vm.currentColor = '#FF0000'

      const gridBefore = JSON.parse(JSON.stringify(vm.grid))

      const mouseEvent = createMouseEvent('click', { clientX: 10, clientY: 10 })
      await canvas.trigger('click', mouseEvent)

      // Grid should remain unchanged (optimization)
      expect(JSON.stringify(vm.grid)).toBe(JSON.stringify(gridBefore))
    })

    it('fills transparent cells with color', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      // Grid is all transparent by default
      vm.tool = 'bucket'
      vm.currentColor = '#00FF00'

      const mouseEvent = createMouseEvent('click', { clientX: 10, clientY: 10 })
      await canvas.trigger('click', mouseEvent)

      // All cells should be filled
      expect(vm.grid[0][0]).toBe('#00FF00')
      expect(vm.grid[10][10]).toBe('#00FF00')
    })

    it('fills colored region back to transparent', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      // Fill a region with color first
      vm.grid[0][0] = '#FF0000'
      vm.grid[0][1] = '#FF0000'
      vm.grid[1][0] = '#FF0000'
      vm.grid[1][1] = '#FF0000'

      vm.tool = 'bucket'
      vm.currentColor = TRANSPARENT

      const mouseEvent = createMouseEvent('click', { clientX: 10, clientY: 10 })
      await canvas.trigger('click', mouseEvent)

      expect(vm.grid[0][0]).toBe(TRANSPARENT)
      expect(vm.grid[0][1]).toBe(TRANSPARENT)
      expect(vm.grid[1][0]).toBe(TRANSPARENT)
      expect(vm.grid[1][1]).toBe(TRANSPARENT)
    })

    it('respects grid boundaries during flood fill', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'bucket'
      vm.currentColor = '#FF0000'

      // Click in corner
      const mouseEvent = createMouseEvent('click', { clientX: 5, clientY: 5 })
      await canvas.trigger('click', mouseEvent)

      // Should not throw and should fill correctly
      expect(vm.grid[0][0]).toBe('#FF0000')
    })

    it('handles complex shapes correctly', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      // Create an L-shape of blue
      vm.grid[5][5] = '#0000FF'
      vm.grid[6][5] = '#0000FF'
      vm.grid[7][5] = '#0000FF'
      vm.grid[7][6] = '#0000FF'
      vm.grid[7][7] = '#0000FF'

      vm.tool = 'bucket'
      vm.currentColor = '#FF0000'

      const mouseEvent = createMouseEvent('click', { clientX: 5 * 15 + 7, clientY: 5 * 15 + 7 })
      await canvas.trigger('click', mouseEvent)

      // All L-shape cells should be filled
      expect(vm.grid[5][5]).toBe('#FF0000')
      expect(vm.grid[6][5]).toBe('#FF0000')
      expect(vm.grid[7][5]).toBe('#FF0000')
      expect(vm.grid[7][6]).toBe('#FF0000')
      expect(vm.grid[7][7]).toBe('#FF0000')

      // Surrounding cells should remain transparent
      expect(vm.grid[4][5]).toBe(TRANSPARENT)
      expect(vm.grid[5][4]).toBe(TRANSPARENT)
    })

    it('uses BFS algorithm (visits all connected cells)', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      // Grid is all transparent, so clicking should fill entire grid
      vm.tool = 'bucket'
      vm.currentColor = '#ABCDEF'

      const mouseEvent = createMouseEvent('click', { clientX: 100, clientY: 100 })
      await canvas.trigger('click', mouseEvent)

      // Check all cells are filled
      let allFilled = true
      for (let y = 0; y < vm.gridHeight; y++) {
        for (let x = 0; x < vm.gridWidth; x++) {
          if (vm.grid[y][x] !== '#ABCDEF') {
            allFilled = false
          }
        }
      }

      expect(allFilled).toBe(true)
    })

    it('handles diagonal boundaries correctly (does not fill diagonally)', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      // Create a diagonal barrier
      vm.grid[1][1] = '#0000FF'

      // Fill top-left transparent region
      vm.tool = 'bucket'
      vm.currentColor = '#FF0000'

      const mouseEvent = createMouseEvent('click', { clientX: 5, clientY: 5 })
      await canvas.trigger('click', mouseEvent)

      // Top-left should be filled
      expect(vm.grid[0][0]).toBe('#FF0000')

      // But should also fill around the barrier (since flood fill only checks 4-directional)
      // Cell at [2][2] should also be filled as it's connected via transparent cells
      expect(vm.grid[2][2]).toBe('#FF0000')
    })

    it('captures state before flood fill', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')
      const historyLengthBefore = vm.history.length

      vm.tool = 'bucket'
      vm.currentColor = '#FF0000'

      const mouseEvent = createMouseEvent('click', { clientX: 10, clientY: 10 })
      await canvas.trigger('click', mouseEvent)

      expect(vm.history.length).toBe(historyLengthBefore + 1)
    })

    it('re-renders grid after flood fill', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')
      const renderGridSpy = vi.spyOn(vm, 'renderGrid')

      vm.tool = 'bucket'
      vm.currentColor = '#FF0000'

      const mouseEvent = createMouseEvent('click', { clientX: 10, clientY: 10 })
      await canvas.trigger('click', mouseEvent)

      expect(renderGridSpy).toHaveBeenCalled()
    })

    it('colorsMatch helper treats null and undefined as transparent', () => {
      const vm = wrapper.vm

      // This tests the internal colorsMatch function indirectly
      // by setting up a scenario where transparent matching is tested
      vm.grid[0][0] = null
      vm.grid[0][1] = undefined
      vm.grid[0][2] = TRANSPARENT

      vm.tool = 'bucket'
      vm.currentColor = '#FF0000'

      // All three cells should be filled (they all match as transparent)
      vm.floodFill(0, 0, '#FF0000')

      expect(vm.grid[0][0]).toBe('#FF0000')
      expect(vm.grid[0][1]).toBe('#FF0000')
      expect(vm.grid[0][2]).toBe('#FF0000')
    })

    it('handles filling from edge cells', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'bucket'
      vm.currentColor = '#FF0000'

      // Click on edge cell (0, 0)
      const mouseEvent = createMouseEvent('click', { clientX: 5, clientY: 5 })
      await canvas.trigger('click', mouseEvent)

      // Should fill from edge without issues
      expect(vm.grid[0][0]).toBe('#FF0000')
    })

    it('handles filling from corner cells', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'bucket'
      vm.currentColor = '#00FF00'

      // Click on bottom-right corner
      const lastX = (vm.gridWidth - 1) * vm.cellSize + 5
      const lastY = (vm.gridHeight - 1) * vm.cellSize + 5
      const mouseEvent = createMouseEvent('click', { clientX: lastX, clientY: lastY })
      await canvas.trigger('click', mouseEvent)

      // Should fill from corner
      expect(vm.grid[vm.gridHeight - 1][vm.gridWidth - 1]).toBe('#00FF00')
    })

    it('fills only 4-directionally connected cells (not diagonal)', async () => {
      const vm = wrapper.vm

      // Create a checkerboard-like pattern
      vm.grid[0][0] = '#FF0000'
      vm.grid[1][1] = '#FF0000'

      // These should not be connected via flood fill
      vm.tool = 'bucket'
      vm.currentColor = '#00FF00'

      vm.floodFill(0, 0, '#00FF00')

      // [0][0] should be filled
      expect(vm.grid[0][0]).toBe('#00FF00')

      // [1][1] should NOT be filled (diagonal only)
      expect(vm.grid[1][1]).toBe('#FF0000')
    })

    it('handles large fill operations efficiently', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      // Fill entire grid (30x30 = 900 cells)
      vm.tool = 'bucket'
      vm.currentColor = '#123456'

      const startTime = performance.now()
      const mouseEvent = createMouseEvent('click', { clientX: 100, clientY: 100 })
      await canvas.trigger('click', mouseEvent)
      const endTime = performance.now()

      // Should complete in reasonable time (< 1 second)
      expect(endTime - startTime).toBeLessThan(1000)

      // And all cells should be filled
      expect(vm.grid[0][0]).toBe('#123456')
      expect(vm.grid[29][29]).toBe('#123456')
    })

    it('bucket fill can replace transparent with transparent (no-op)', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      // Grid is all transparent
      vm.tool = 'bucket'
      vm.currentColor = TRANSPARENT

      const gridBefore = JSON.parse(JSON.stringify(vm.grid))

      const mouseEvent = createMouseEvent('click', { clientX: 10, clientY: 10 })
      await canvas.trigger('click', mouseEvent)

      // Should be no-op
      expect(JSON.stringify(vm.grid)).toBe(JSON.stringify(gridBefore))
    })

    it('flood fill updates queue correctly during BFS', () => {
      const vm = wrapper.vm

      // Create a simple 2x2 region
      vm.grid[5][5] = '#FF0000'
      vm.grid[5][6] = '#FF0000'
      vm.grid[6][5] = '#FF0000'
      vm.grid[6][6] = '#FF0000'

      vm.floodFill(5, 5, '#00FF00')

      // All 4 cells should be filled
      expect(vm.grid[5][5]).toBe('#00FF00')
      expect(vm.grid[5][6]).toBe('#00FF00')
      expect(vm.grid[6][5]).toBe('#00FF00')
      expect(vm.grid[6][6]).toBe('#00FF00')
    })
  })

  /**
   * SECTION 5: Undo/Redo (35 tests)
   */
  describe('Undo/Redo System', () => {
    it('initializes with undo disabled', () => {
      const vm = wrapper.vm
      const undoBtn = wrapper.findAll('button').find(btn => btn.text().includes('Undo'))

      // Only initial state, so can't undo
      expect(vm.canUndo).toBe(false)
      expect(undoBtn.attributes('disabled')).toBeDefined()
    })

    it('initializes with redo disabled', () => {
      const vm = wrapper.vm
      const redoBtn = wrapper.findAll('button').find(btn => btn.text().includes('Redo'))

      expect(vm.canRedo).toBe(false)
      expect(redoBtn.attributes('disabled')).toBeDefined()
    })

    it('enables undo after making a change', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'draw'
      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)
      await canvas.trigger('mouseup')

      expect(vm.canUndo).toBe(true)
    })

    it('undoes drawing action', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'draw'
      vm.currentColor = '#FF0000'

      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)
      await canvas.trigger('mouseup')

      expect(vm.grid[0][0]).toBe('#FF0000')

      vm.undo()
      await nextTick()

      expect(vm.grid[0][0]).toBe(TRANSPARENT)
    })

    it('enables redo after undo', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'draw'
      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)
      await canvas.trigger('mouseup')

      vm.undo()
      await nextTick()

      expect(vm.canRedo).toBe(true)
    })

    it('redoes undone action', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'draw'
      vm.currentColor = '#FF0000'

      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)
      await canvas.trigger('mouseup')

      vm.undo()
      await nextTick()

      vm.redo()
      await nextTick()

      expect(vm.grid[0][0]).toBe('#FF0000')
    })

    it('supports multiple undo steps', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'draw'

      // Draw 3 different cells
      for (let i = 0; i < 3; i++) {
        vm.currentColor = `#${i}${i}${i}${i}${i}${i}`
        const mouseEvent = createMouseEvent('mousedown', { clientX: 10 + i * 15, clientY: 10 })
        await canvas.trigger('mousedown', mouseEvent)
        await canvas.trigger('mouseup')
      }

      expect(vm.grid[0][0]).not.toBe(TRANSPARENT)
      expect(vm.grid[0][1]).not.toBe(TRANSPARENT)
      expect(vm.grid[0][2]).not.toBe(TRANSPARENT)

      // Undo all 3
      vm.undo()
      await nextTick()
      vm.undo()
      await nextTick()
      vm.undo()
      await nextTick()

      expect(vm.grid[0][0]).toBe(TRANSPARENT)
      expect(vm.grid[0][1]).toBe(TRANSPARENT)
      expect(vm.grid[0][2]).toBe(TRANSPARENT)
    })

    it('supports multiple redo steps', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'draw'
      vm.currentColor = '#FF0000'

      // Draw 2 cells
      for (let i = 0; i < 2; i++) {
        const mouseEvent = createMouseEvent('mousedown', { clientX: 10 + i * 15, clientY: 10 })
        await canvas.trigger('mousedown', mouseEvent)
        await canvas.trigger('mouseup')
      }

      // Undo both
      vm.undo()
      await nextTick()
      vm.undo()
      await nextTick()

      // Redo both
      vm.redo()
      await nextTick()
      vm.redo()
      await nextTick()

      expect(vm.grid[0][0]).toBe('#FF0000')
      expect(vm.grid[0][1]).toBe('#FF0000')
    })

    it('clears redo history when making new action after undo', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'draw'

      // Draw, undo, then draw again
      const mouseEvent1 = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent1)
      await canvas.trigger('mouseup')

      vm.undo()
      await nextTick()

      const mouseEvent2 = createMouseEvent('mousedown', { clientX: 25, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent2)
      await canvas.trigger('mouseup')

      // Redo should now be disabled
      expect(vm.canRedo).toBe(false)
    })

    it('blocks undo during drawing', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'draw'
      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)

      // Now isDrawing is true
      expect(vm.isDrawing).toBe(true)

      const gridBefore = JSON.parse(JSON.stringify(vm.grid))
      vm.undo()
      await nextTick()

      // Grid should not change (undo blocked)
      expect(JSON.stringify(vm.grid)).toBe(JSON.stringify(gridBefore))
    })

    it('blocks redo during drawing', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      // Setup: draw, undo, then start drawing again
      vm.tool = 'draw'
      const mouseEvent1 = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent1)
      await canvas.trigger('mouseup')

      vm.undo()
      await nextTick()

      const mouseEvent2 = createMouseEvent('mousedown', { clientX: 25, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent2)

      // Now isDrawing is true
      const gridBefore = JSON.parse(JSON.stringify(vm.grid))
      vm.redo()
      await nextTick()

      // Grid should not change (redo blocked)
      expect(JSON.stringify(vm.grid)).toBe(JSON.stringify(gridBefore))
    })

    it('undo restores exact grid state', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      const originalGrid = JSON.parse(JSON.stringify(vm.grid))

      vm.tool = 'draw'
      vm.currentColor = '#FF0000'
      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)
      await canvas.trigger('mouseup')

      vm.undo()
      await nextTick()

      expect(JSON.stringify(vm.grid)).toBe(JSON.stringify(originalGrid))
    })

    it('undo restores grid dimensions', async () => {
      const vm = wrapper.vm

      const originalWidth = vm.gridWidth
      const originalHeight = vm.gridHeight

      // Resize grid
      vm.gridWidth = 40
      vm.gridHeight = 40
      vm.resizeGrid()
      await nextTick()

      expect(vm.gridWidth).toBe(40)
      expect(vm.gridHeight).toBe(40)

      vm.undo()
      await nextTick()

      expect(vm.gridWidth).toBe(originalWidth)
      expect(vm.gridHeight).toBe(originalHeight)
    })

    it('history stores grid snapshot, width, and height', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'draw'
      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)
      await canvas.trigger('mouseup')

      const lastSnapshot = vm.history[vm.history.length - 1]

      expect(lastSnapshot).toHaveProperty('grid')
      expect(lastSnapshot).toHaveProperty('width')
      expect(lastSnapshot).toHaveProperty('height')
      expect(Array.isArray(lastSnapshot.grid)).toBe(true)
    })

    it('createSnapshot creates deep copy of grid', () => {
      const vm = wrapper.vm

      vm.grid[0][0] = '#FF0000'
      const snapshot = vm.createSnapshot()

      // Modify original
      vm.grid[0][0] = '#00FF00'

      // Snapshot should be unchanged
      expect(snapshot.grid[0][0]).toBe('#FF0000')
    })

    it('restoreState re-renders grid', () => {
      const vm = wrapper.vm
      const renderGridSpy = vi.spyOn(vm, 'renderGrid')

      const snapshot = vm.createSnapshot()
      vm.restoreState(snapshot)

      expect(renderGridSpy).toHaveBeenCalled()
    })

    it('clicking undo button triggers undo', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      // Make a change
      vm.tool = 'draw'
      vm.currentColor = '#FF0000'
      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)
      await canvas.trigger('mouseup')

      expect(vm.grid[0][0]).toBe('#FF0000')

      const undoBtn = wrapper.findAll('button').find(btn => btn.text().includes('Undo'))
      await undoBtn.trigger('click')

      expect(vm.grid[0][0]).toBe(TRANSPARENT)
    })

    it('clicking redo button triggers redo', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      // Make a change and undo it
      vm.tool = 'draw'
      vm.currentColor = '#FF0000'
      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)
      await canvas.trigger('mouseup')

      vm.undo()
      await nextTick()

      expect(vm.grid[0][0]).toBe(TRANSPARENT)

      const redoBtn = wrapper.findAll('button').find(btn => btn.text().includes('Redo'))
      await redoBtn.trigger('click')

      expect(vm.grid[0][0]).toBe('#FF0000')
    })

    it('supports undo after bucket fill', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'bucket'
      vm.currentColor = '#ABCDEF'

      const mouseEvent = createMouseEvent('click', { clientX: 10, clientY: 10 })
      await canvas.trigger('click', mouseEvent)

      // Grid should be filled
      expect(vm.grid[0][0]).toBe('#ABCDEF')

      vm.undo()
      await nextTick()

      // Should be back to transparent
      expect(vm.grid[0][0]).toBe(TRANSPARENT)
    })

    it('supports undo after erase', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      // Draw then erase
      vm.grid[0][0] = '#FF0000'

      vm.tool = 'erase'
      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)
      await canvas.trigger('mouseup')

      expect(vm.grid[0][0]).toBe(TRANSPARENT)

      vm.undo()
      await nextTick()

      expect(vm.grid[0][0]).toBe('#FF0000')
    })

    it('maintains history integrity with mixed operations', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      // Draw
      vm.tool = 'draw'
      vm.currentColor = '#FF0000'
      let mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)
      await canvas.trigger('mouseup')

      // Erase
      vm.tool = 'erase'
      mouseEvent = createMouseEvent('mousedown', { clientX: 25, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)
      await canvas.trigger('mouseup')

      // Bucket fill
      vm.tool = 'bucket'
      vm.currentColor = '#00FF00'
      mouseEvent = createMouseEvent('click', { clientX: 40, clientY: 10 })
      await canvas.trigger('click', mouseEvent)

      // Should have 4 states: initial + 3 operations
      expect(vm.history.length).toBe(4)

      // Undo all
      vm.undo()
      await nextTick()
      vm.undo()
      await nextTick()
      vm.undo()
      await nextTick()

      // Should be back to initial state
      expect(vm.canUndo).toBe(false)
    })

    it('does not exceed memory with unlimited history', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'draw'

      // Perform many operations
      for (let i = 0; i < 50; i++) {
        const mouseEvent = createMouseEvent('mousedown', { clientX: 10 + (i % 10) * 15, clientY: 10 })
        await canvas.trigger('mousedown', mouseEvent)
        await canvas.trigger('mouseup')
      }

      // History should contain all operations + initial state
      expect(vm.history.length).toBe(51)
    })

    it('historyIndex points to current state', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      const initialIndex = vm.historyIndex

      vm.tool = 'draw'
      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)
      await canvas.trigger('mouseup')

      expect(vm.historyIndex).toBe(initialIndex + 1)

      vm.undo()
      await nextTick()

      expect(vm.historyIndex).toBe(initialIndex)
    })

    it('canUndo is false when at initial state', () => {
      const vm = wrapper.vm
      expect(vm.historyIndex).toBe(0)
      expect(vm.canUndo).toBe(false)
    })

    it('canRedo is false when at latest state', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'draw'
      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)
      await canvas.trigger('mouseup')

      // At latest state
      expect(vm.historyIndex).toBe(vm.history.length - 1)
      expect(vm.canRedo).toBe(false)
    })

    it('history persists through tool switches', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'draw'
      const mouseEvent1 = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent1)
      await canvas.trigger('mouseup')

      const historyLength = vm.history.length

      // Switch tool
      vm.tool = 'erase'
      await nextTick()

      // History should be unchanged
      expect(vm.history.length).toBe(historyLength)
    })

    it('history persists through color changes', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'draw'
      vm.currentColor = '#FF0000'
      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)
      await canvas.trigger('mouseup')

      const historyLength = vm.history.length

      // Change color
      vm.currentColor = '#00FF00'
      await nextTick()

      // History should be unchanged
      expect(vm.history.length).toBe(historyLength)
    })

    it('undo updates historyIndex correctly', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'draw'
      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)
      await canvas.trigger('mouseup')

      const indexBefore = vm.historyIndex
      vm.undo()
      await nextTick()

      expect(vm.historyIndex).toBe(indexBefore - 1)
    })

    it('redo updates historyIndex correctly', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      vm.tool = 'draw'
      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)
      await canvas.trigger('mouseup')

      vm.undo()
      await nextTick()

      const indexBefore = vm.historyIndex
      vm.redo()
      await nextTick()

      expect(vm.historyIndex).toBe(indexBefore + 1)
    })

    it('slices future history when performing action after undo', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      // Perform 3 actions
      vm.tool = 'draw'
      for (let i = 0; i < 3; i++) {
        const mouseEvent = createMouseEvent('mousedown', { clientX: 10 + i * 15, clientY: 10 })
        await canvas.trigger('mousedown', mouseEvent)
        await canvas.trigger('mouseup')
      }

      expect(vm.history.length).toBe(4) // initial + 3

      // Undo 2 times
      vm.undo()
      await nextTick()
      vm.undo()
      await nextTick()

      expect(vm.historyIndex).toBe(1)

      // Perform new action
      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 25 })
      await canvas.trigger('mousedown', mouseEvent)
      await canvas.trigger('mouseup')

      // History should be sliced and new action added
      expect(vm.history.length).toBe(3) // initial + 1 remaining + 1 new
    })

    it('restoreState creates deep copy when restoring', () => {
      const vm = wrapper.vm

      vm.grid[0][0] = '#FF0000'
      const snapshot = vm.createSnapshot()

      vm.grid[0][0] = '#00FF00'
      vm.restoreState(snapshot)

      // Modifying current grid should not affect snapshot
      vm.grid[0][0] = '#0000FF'
      expect(snapshot.grid[0][0]).toBe('#FF0000')
    })
  })

  /**
   * SECTION 6: Grid Operations (25 tests)
   */
  describe('Grid Operations', () => {
    it('resizes grid when clicking resize button', async () => {
      const vm = wrapper.vm

      vm.gridWidth = 40
      vm.gridHeight = 50

      const resizeBtn = wrapper.findAll('button').find(btn => btn.text().includes('Resize'))
      await resizeBtn.trigger('click')

      expect(vm.grid.length).toBe(50)
      expect(vm.grid[0].length).toBe(40)
    })

    it('centers existing content when resizing larger', async () => {
      const vm = wrapper.vm

      // Draw in center of current grid
      vm.grid[15][15] = '#FF0000'

      // Resize to larger
      vm.gridWidth = 50
      vm.gridHeight = 50
      vm.resizeGrid()
      await nextTick()

      // Content should be centered
      const expectedY = 15 + Math.floor((50 - 30) / 2)
      const expectedX = 15 + Math.floor((50 - 30) / 2)

      expect(vm.grid[expectedY][expectedX]).toBe('#FF0000')
    })

    it('crops content when resizing smaller', async () => {
      const vm = wrapper.vm

      // Draw at edges
      vm.grid[0][0] = '#FF0000'
      vm.grid[29][29] = '#00FF00'

      // Resize to smaller
      vm.gridWidth = 20
      vm.gridHeight = 20
      vm.resizeGrid()
      await nextTick()

      expect(vm.grid.length).toBe(20)
      expect(vm.grid[0].length).toBe(20)

      // Edge content should be cropped
      // Center content might be preserved depending on centering
    })

    it('adds row to top', async () => {
      const vm = wrapper.vm
      const initialHeight = vm.gridHeight

      vm.grid[0][0] = '#FF0000'

      vm.addRowTop()
      await nextTick()

      expect(vm.gridHeight).toBe(initialHeight + 1)
      expect(vm.grid.length).toBe(initialHeight + 1)

      // New row should be transparent
      expect(vm.grid[0][0]).toBe(TRANSPARENT)

      // Old content shifted down
      expect(vm.grid[1][0]).toBe('#FF0000')
    })

    it('adds row to bottom', async () => {
      const vm = wrapper.vm
      const initialHeight = vm.gridHeight

      vm.grid[29][0] = '#FF0000'

      vm.addRowBottom()
      await nextTick()

      expect(vm.gridHeight).toBe(initialHeight + 1)
      expect(vm.grid.length).toBe(initialHeight + 1)

      // New row should be transparent
      expect(vm.grid[30][0]).toBe(TRANSPARENT)

      // Old content unchanged
      expect(vm.grid[29][0]).toBe('#FF0000')
    })

    it('adds column to left', async () => {
      const vm = wrapper.vm
      const initialWidth = vm.gridWidth

      vm.grid[0][0] = '#FF0000'

      vm.addColumnLeft()
      await nextTick()

      expect(vm.gridWidth).toBe(initialWidth + 1)
      expect(vm.grid[0].length).toBe(initialWidth + 1)

      // New column should be transparent
      expect(vm.grid[0][0]).toBe(TRANSPARENT)

      // Old content shifted right
      expect(vm.grid[0][1]).toBe('#FF0000')
    })

    it('adds column to right', async () => {
      const vm = wrapper.vm
      const initialWidth = vm.gridWidth

      vm.grid[0][29] = '#FF0000'

      vm.addColumnRight()
      await nextTick()

      expect(vm.gridWidth).toBe(initialWidth + 1)
      expect(vm.grid[0].length).toBe(initialWidth + 1)

      // New column should be transparent
      expect(vm.grid[0][30]).toBe(TRANSPARENT)

      // Old content unchanged
      expect(vm.grid[0][29]).toBe('#FF0000')
    })

    it('removes row from top', async () => {
      const vm = wrapper.vm
      const initialHeight = vm.gridHeight

      vm.grid[0][0] = '#FF0000'
      vm.grid[1][0] = '#00FF00'

      vm.removeRowTop()
      await nextTick()

      expect(vm.gridHeight).toBe(initialHeight - 1)
      expect(vm.grid.length).toBe(initialHeight - 1)

      // First row removed, second row is now first
      expect(vm.grid[0][0]).toBe('#00FF00')
    })

    it('removes row from bottom', async () => {
      const vm = wrapper.vm
      const initialHeight = vm.gridHeight

      vm.grid[29][0] = '#FF0000'
      vm.grid[28][0] = '#00FF00'

      vm.removeRowBottom()
      await nextTick()

      expect(vm.gridHeight).toBe(initialHeight - 1)
      expect(vm.grid.length).toBe(initialHeight - 1)

      // Last row removed
      expect(vm.grid[28][0]).toBe('#00FF00')
      expect(vm.grid.length).toBe(29)
    })

    it('removes column from left', async () => {
      const vm = wrapper.vm
      const initialWidth = vm.gridWidth

      vm.grid[0][0] = '#FF0000'
      vm.grid[0][1] = '#00FF00'

      vm.removeColumnLeft()
      await nextTick()

      expect(vm.gridWidth).toBe(initialWidth - 1)
      expect(vm.grid[0].length).toBe(initialWidth - 1)

      // First column removed, second column is now first
      expect(vm.grid[0][0]).toBe('#00FF00')
    })

    it('removes column from right', async () => {
      const vm = wrapper.vm
      const initialWidth = vm.gridWidth

      vm.grid[0][29] = '#FF0000'
      vm.grid[0][28] = '#00FF00'

      vm.removeColumnRight()
      await nextTick()

      expect(vm.gridWidth).toBe(initialWidth - 1)
      expect(vm.grid[0].length).toBe(initialWidth - 1)

      // Last column removed
      expect(vm.grid[0][28]).toBe('#00FF00')
      expect(vm.grid[0].length).toBe(29)
    })

    it('does not remove row if height <= 5', async () => {
      const vm = wrapper.vm

      // Shrink to minimum
      while (vm.gridHeight > 5) {
        vm.removeRowTop()
      }

      expect(vm.gridHeight).toBe(5)

      // Try to remove further
      vm.removeRowTop()
      await nextTick()

      expect(vm.gridHeight).toBe(5)
    })

    it('does not remove column if width <= 5', async () => {
      const vm = wrapper.vm

      // Shrink to minimum
      while (vm.gridWidth > 5) {
        vm.removeColumnLeft()
      }

      expect(vm.gridWidth).toBe(5)

      // Try to remove further
      vm.removeColumnLeft()
      await nextTick()

      expect(vm.gridWidth).toBe(5)
    })

    it('disables remove buttons when at minimum size', async () => {
      const vm = wrapper.vm

      // Shrink to minimum
      while (vm.gridHeight > 5) {
        vm.removeRowTop()
      }
      while (vm.gridWidth > 5) {
        vm.removeColumnLeft()
      }

      await nextTick()

      const removeButtons = wrapper.findAll('.btn-remove')
      removeButtons.forEach(btn => {
        expect(btn.attributes('disabled')).toBeDefined()
      })
    })

    it('updates grid info display after modifications', async () => {
      const vm = wrapper.vm

      vm.addRowTop()
      await nextTick()

      const gridInfo = wrapper.find('.grid-info')
      expect(gridInfo.text()).toBe('31Ã—30')

      vm.addColumnRight()
      await nextTick()

      expect(gridInfo.text()).toBe('31Ã—31')
    })

    it('re-renders grid after add row', () => {
      const vm = wrapper.vm
      const renderGridSpy = vi.spyOn(vm, 'renderGrid')

      vm.addRowTop()

      expect(renderGridSpy).toHaveBeenCalled()
    })

    it('re-renders grid after remove column', () => {
      const vm = wrapper.vm
      const renderGridSpy = vi.spyOn(vm, 'renderGrid')

      vm.removeColumnRight()

      expect(renderGridSpy).toHaveBeenCalled()
    })

    it('captures state before grid modifications', async () => {
      const vm = wrapper.vm
      const historyLengthBefore = vm.history.length

      vm.addRowTop()
      await nextTick()

      expect(vm.history.length).toBe(historyLengthBefore + 1)
    })

    it('supports undo after adding row', async () => {
      const vm = wrapper.vm
      const initialHeight = vm.gridHeight

      vm.addRowTop()
      await nextTick()

      expect(vm.gridHeight).toBe(initialHeight + 1)

      vm.undo()
      await nextTick()

      expect(vm.gridHeight).toBe(initialHeight)
    })

    it('supports undo after removing column', async () => {
      const vm = wrapper.vm
      const initialWidth = vm.gridWidth

      vm.removeColumnLeft()
      await nextTick()

      expect(vm.gridWidth).toBe(initialWidth - 1)

      vm.undo()
      await nextTick()

      expect(vm.gridWidth).toBe(initialWidth)
    })

    it('clicking grid control buttons works', async () => {
      const vm = wrapper.vm

      const addRowTopBtn = wrapper.findAll('button').find(btn => btn.text().includes('Add Row Top'))
      await addRowTopBtn.trigger('click')

      expect(vm.gridHeight).toBe(31)
    })

    it('preserves content when adding then removing row', async () => {
      const vm = wrapper.vm

      vm.grid[0][0] = '#FF0000'

      vm.addRowTop()
      await nextTick()

      // Content shifted down
      expect(vm.grid[1][0]).toBe('#FF0000')

      vm.removeRowTop()
      await nextTick()

      // Content back to original position
      expect(vm.grid[0][0]).toBe('#FF0000')
    })

    it('handles adding multiple rows in sequence', async () => {
      const vm = wrapper.vm
      const initialHeight = vm.gridHeight

      for (let i = 0; i < 5; i++) {
        vm.addRowBottom()
      }

      await nextTick()

      expect(vm.gridHeight).toBe(initialHeight + 5)
    })

    it('handles adding multiple columns in sequence', async () => {
      const vm = wrapper.vm
      const initialWidth = vm.gridWidth

      for (let i = 0; i < 5; i++) {
        vm.addColumnRight()
      }

      await nextTick()

      expect(vm.gridWidth).toBe(initialWidth + 5)
    })

    it('updates canvas dimensions after grid resize', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas').element

      vm.gridWidth = 40
      vm.gridHeight = 50
      vm.resizeGrid()
      await nextTick()

      expect(canvas.width).toBe(40 * 15)
      expect(canvas.height).toBe(50 * 15)
    })
  })

  /**
   * SECTION 7: Keyboard Shortcuts (15 tests)
   */
  describe('Keyboard Shortcuts', () => {
    it('triggers undo on Ctrl+Z', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      // Make a change
      vm.tool = 'draw'
      vm.currentColor = '#FF0000'
      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)
      await canvas.trigger('mouseup')

      expect(vm.grid[0][0]).toBe('#FF0000')

      // Trigger Ctrl+Z
      const keyEvent = createKeyboardEvent('z', { ctrlKey: true })
      window.dispatchEvent(keyEvent)
      await nextTick()

      expect(vm.grid[0][0]).toBe(TRANSPARENT)
    })

    it('triggers undo on Cmd+Z (Mac)', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      // Make a change
      vm.tool = 'draw'
      vm.currentColor = '#FF0000'
      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)
      await canvas.trigger('mouseup')

      // Trigger Cmd+Z
      const keyEvent = createKeyboardEvent('z', { metaKey: true })
      window.dispatchEvent(keyEvent)
      await nextTick()

      expect(vm.grid[0][0]).toBe(TRANSPARENT)
    })

    it('triggers redo on Ctrl+Y', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      // Make a change and undo
      vm.tool = 'draw'
      vm.currentColor = '#FF0000'
      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)
      await canvas.trigger('mouseup')

      vm.undo()
      await nextTick()

      // Trigger Ctrl+Y
      const keyEvent = createKeyboardEvent('y', { ctrlKey: true })
      window.dispatchEvent(keyEvent)
      await nextTick()

      expect(vm.grid[0][0]).toBe('#FF0000')
    })

    it('triggers redo on Ctrl+Shift+Z', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      // Make a change and undo
      vm.tool = 'draw'
      vm.currentColor = '#FF0000'
      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)
      await canvas.trigger('mouseup')

      vm.undo()
      await nextTick()

      // Trigger Ctrl+Shift+Z
      const keyEvent = createKeyboardEvent('z', { ctrlKey: true, shiftKey: true })
      window.dispatchEvent(keyEvent)
      await nextTick()

      expect(vm.grid[0][0]).toBe('#FF0000')
    })

    it('triggers redo on Cmd+Shift+Z (Mac)', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      // Make a change and undo
      vm.tool = 'draw'
      vm.currentColor = '#FF0000'
      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)
      await canvas.trigger('mouseup')

      vm.undo()
      await nextTick()

      // Trigger Cmd+Shift+Z
      const keyEvent = createKeyboardEvent('z', { metaKey: true, shiftKey: true })
      window.dispatchEvent(keyEvent)
      await nextTick()

      expect(vm.grid[0][0]).toBe('#FF0000')
    })

    it('prevents default browser behavior for Ctrl+Z', () => {
      const keyEvent = createKeyboardEvent('z', { ctrlKey: true })
      const preventDefaultSpy = vi.spyOn(keyEvent, 'preventDefault')

      window.dispatchEvent(keyEvent)

      expect(preventDefaultSpy).toHaveBeenCalled()
    })

    it('prevents default browser behavior for Ctrl+Y', () => {
      const keyEvent = createKeyboardEvent('y', { ctrlKey: true })
      const preventDefaultSpy = vi.spyOn(keyEvent, 'preventDefault')

      window.dispatchEvent(keyEvent)

      expect(preventDefaultSpy).toHaveBeenCalled()
    })

    it('does not trigger undo when isDrawing is true', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      // Start drawing
      vm.tool = 'draw'
      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)

      expect(vm.isDrawing).toBe(true)

      const gridBefore = JSON.parse(JSON.stringify(vm.grid))

      // Try to undo
      const keyEvent = createKeyboardEvent('z', { ctrlKey: true })
      window.dispatchEvent(keyEvent)
      await nextTick()

      // Grid should be unchanged
      expect(JSON.stringify(vm.grid)).toBe(JSON.stringify(gridBefore))
    })

    it('does not trigger redo when isDrawing is true', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      // Make a change, undo, then start drawing
      vm.tool = 'draw'
      const mouseEvent1 = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent1)
      await canvas.trigger('mouseup')

      vm.undo()
      await nextTick()

      const mouseEvent2 = createMouseEvent('mousedown', { clientX: 25, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent2)

      expect(vm.isDrawing).toBe(true)

      const gridBefore = JSON.parse(JSON.stringify(vm.grid))

      // Try to redo
      const keyEvent = createKeyboardEvent('y', { ctrlKey: true })
      window.dispatchEvent(keyEvent)
      await nextTick()

      // Grid should be unchanged
      expect(JSON.stringify(vm.grid)).toBe(JSON.stringify(gridBefore))
    })

    it('ignores Ctrl+Z with additional modifiers', () => {
      const vm = wrapper.vm
      const undoSpy = vi.spyOn(vm, 'undo')

      // Ctrl+Shift+Z should trigger redo, not undo
      const keyEvent = createKeyboardEvent('z', { ctrlKey: true, shiftKey: true })
      window.dispatchEvent(keyEvent)

      expect(undoSpy).not.toHaveBeenCalled()
    })

    it('registers keydown listener on mount', () => {
      const addEventListenerSpy = vi.spyOn(window, 'addEventListener')

      // Mount new component
      const newWrapper = mount(CreateDesign, {
        global: {
          mocks: {
            $router: mockRouter
          }
        }
      })

      expect(addEventListenerSpy).toHaveBeenCalledWith('keydown', expect.any(Function))

      newWrapper.unmount()
    })

    it('removes keydown listener on unmount', () => {
      const removeEventListenerSpy = vi.spyOn(window, 'removeEventListener')

      wrapper.unmount()

      expect(removeEventListenerSpy).toHaveBeenCalledWith('keydown', expect.any(Function))
    })

    it('supports rapid undo/redo via keyboard', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      // Make 3 changes
      vm.tool = 'draw'
      for (let i = 0; i < 3; i++) {
        const mouseEvent = createMouseEvent('mousedown', { clientX: 10 + i * 15, clientY: 10 })
        await canvas.trigger('mousedown', mouseEvent)
        await canvas.trigger('mouseup')
      }

      // Rapid undo 3 times
      for (let i = 0; i < 3; i++) {
        const keyEvent = createKeyboardEvent('z', { ctrlKey: true })
        window.dispatchEvent(keyEvent)
        await nextTick()
      }

      expect(vm.canUndo).toBe(false)

      // Rapid redo 3 times
      for (let i = 0; i < 3; i++) {
        const keyEvent = createKeyboardEvent('y', { ctrlKey: true })
        window.dispatchEvent(keyEvent)
        await nextTick()
      }

      expect(vm.canRedo).toBe(false)
    })

    it('keyboard shortcuts work with both Ctrl and Cmd', async () => {
      const vm = wrapper.vm
      const canvas = wrapper.find('canvas')

      // Make a change
      vm.tool = 'draw'
      const mouseEvent = createMouseEvent('mousedown', { clientX: 10, clientY: 10 })
      await canvas.trigger('mousedown', mouseEvent)
      await canvas.trigger('mouseup')

      // Undo with Cmd
      let keyEvent = createKeyboardEvent('z', { metaKey: true })
      window.dispatchEvent(keyEvent)
      await nextTick()

      expect(vm.historyIndex).toBe(0)

      // Redo with Ctrl
      keyEvent = createKeyboardEvent('y', { ctrlKey: true })
      window.dispatchEvent(keyEvent)
      await nextTick()

      expect(vm.historyIndex).toBe(1)
    })

    it('keyboard shortcuts respect canUndo and canRedo', async () => {
      const vm = wrapper.vm

      // Try to undo when at initial state
      expect(vm.canUndo).toBe(false)

      const keyEvent = createKeyboardEvent('z', { ctrlKey: true })
      window.dispatchEvent(keyEvent)
      await nextTick()

      // historyIndex should remain 0
      expect(vm.historyIndex).toBe(0)
    })
  })

  /**
   * SECTION 8: Save Functionality (20 tests)
   */
  describe('Save Functionality', () => {
    it('renders save button', () => {
      const saveBtn = wrapper.findAll('button').find(btn => btn.text().includes('Save Design'))
      expect(saveBtn.exists()).toBe(true)
    })

    it('renders title input', () => {
      const titleInput = wrapper.find('input[type="text"]')
      expect(titleInput.exists()).toBe(true)
    })

    it('renders description textarea', () => {
      const descriptionTextarea = wrapper.find('textarea')
      expect(descriptionTextarea.exists()).toBe(true)
    })

    it('updates title when typing', async () => {
      const vm = wrapper.vm
      const titleInput = wrapper.find('input[placeholder="My Cross-Stitch Pattern"]')

      await titleInput.setValue('My Design')

      expect(vm.title).toBe('My Design')
    })

    it('updates description when typing', async () => {
      const vm = wrapper.vm
      const descriptionTextarea = wrapper.find('textarea')

      await descriptionTextarea.setValue('A beautiful pattern')

      expect(vm.description).toBe('A beautiful pattern')
    })

    it('shows error when saving without title', async () => {
      const vm = wrapper.vm

      vm.title = ''
      await vm.saveDesign()

      expect(vm.saveError).toBe('Please enter a title')
    })

    it('shows error when saving with only whitespace title', async () => {
      const vm = wrapper.vm

      vm.title = '   '
      await vm.saveDesign()

      expect(vm.saveError).toBe('Please enter a title')
    })

    it('calls designsAPI.create when saving with valid data', async () => {
      const vm = wrapper.vm

      designsAPI.create.mockResolvedValue({ data: { id: 1 } })

      vm.title = 'Test Design'
      vm.description = 'Test Description'

      await vm.saveDesign()

      expect(designsAPI.create).toHaveBeenCalled()
    })

    it('sends correct data structure to API', async () => {
      const vm = wrapper.vm

      designsAPI.create.mockResolvedValue({ data: { id: 1 } })

      vm.title = 'Test Design'
      vm.description = 'Test Description'
      vm.grid[0][0] = '#FF0000'

      await vm.saveDesign()

      const callArg = designsAPI.create.mock.calls[0][0]

      expect(callArg).toHaveProperty('title', 'Test Design')
      expect(callArg).toHaveProperty('description', 'Test Description')
      expect(callArg).toHaveProperty('width', 30)
      expect(callArg).toHaveProperty('height', 30)
      expect(callArg).toHaveProperty('design_data')
    })

    it('serializes grid as JSON in design_data', async () => {
      const vm = wrapper.vm

      designsAPI.create.mockResolvedValue({ data: { id: 1 } })

      vm.title = 'Test'
      await vm.saveDesign()

      const callArg = designsAPI.create.mock.calls[0][0]
      const designData = JSON.parse(callArg.design_data)

      expect(designData).toHaveProperty('grid')
      expect(designData).toHaveProperty('palette')
      expect(Array.isArray(designData.grid)).toBe(true)
      expect(Array.isArray(designData.palette)).toBe(true)
    })

    it('extracts unique colors for palette', async () => {
      const vm = wrapper.vm

      designsAPI.create.mockResolvedValue({ data: { id: 1 } })

      vm.title = 'Test'
      vm.grid[0][0] = '#FF0000'
      vm.grid[0][1] = '#00FF00'
      vm.grid[0][2] = '#FF0000' // Duplicate

      await vm.saveDesign()

      const callArg = designsAPI.create.mock.calls[0][0]
      const designData = JSON.parse(callArg.design_data)

      expect(designData.palette.length).toBe(2)
      expect(designData.palette).toContain('#FF0000')
      expect(designData.palette).toContain('#00FF00')
    })

    it('excludes transparent from palette', async () => {
      const vm = wrapper.vm

      designsAPI.create.mockResolvedValue({ data: { id: 1 } })

      vm.title = 'Test'
      vm.grid[0][0] = '#FF0000'
      vm.grid[0][1] = TRANSPARENT

      await vm.saveDesign()

      const callArg = designsAPI.create.mock.calls[0][0]
      const designData = JSON.parse(callArg.design_data)

      expect(designData.palette.length).toBe(1)
      expect(designData.palette).toContain('#FF0000')
      expect(designData.palette).not.toContain(TRANSPARENT)
    })

    it('sets saving state to true during save', async () => {
      const vm = wrapper.vm

      designsAPI.create.mockImplementation(() => new Promise(resolve => {
        expect(vm.saving).toBe(true)
        resolve({ data: { id: 1 } })
      }))

      vm.title = 'Test'
      await vm.saveDesign()
    })

    it('sets saving state to false after save', async () => {
      const vm = wrapper.vm

      designsAPI.create.mockResolvedValue({ data: { id: 1 } })

      vm.title = 'Test'
      await vm.saveDesign()

      expect(vm.saving).toBe(false)
    })

    it('disables save button while saving', async () => {
      const vm = wrapper.vm

      vm.saving = true
      await nextTick()

      const saveBtn = wrapper.findAll('button').find(btn => btn.text().includes('Saving'))
      expect(saveBtn.attributes('disabled')).toBeDefined()
    })

    it('shows "Saving..." text while saving', async () => {
      const vm = wrapper.vm

      vm.saving = true
      await nextTick()

      const saveBtn = wrapper.findAll('button').find(btn => btn.text().includes('Saving'))
      expect(saveBtn.text()).toBe('Saving...')
    })

    it('redirects to /designs after successful save', async () => {
      const vm = wrapper.vm

      designsAPI.create.mockResolvedValue({ data: { id: 1 } })

      vm.title = 'Test'
      await vm.saveDesign()
      await flushPromises()

      expect(mockRouter.push).toHaveBeenCalledWith('/designs')
    })

    it('shows error message on save failure', async () => {
      const vm = wrapper.vm

      designsAPI.create.mockRejectedValue({
        response: { data: { detail: 'Server error' } }
      })

      vm.title = 'Test'
      await vm.saveDesign()

      expect(vm.saveError).toBe('Server error')
    })

    it('shows generic error if no detail in response', async () => {
      const vm = wrapper.vm

      designsAPI.create.mockRejectedValue(new Error('Network error'))

      vm.title = 'Test'
      await vm.saveDesign()

      expect(vm.saveError).toBe('Failed to save design')
    })

    it('clears saveError before new save attempt', async () => {
      const vm = wrapper.vm

      vm.saveError = 'Previous error'
      designsAPI.create.mockResolvedValue({ data: { id: 1 } })

      vm.title = 'Test'
      await vm.saveDesign()

      expect(vm.saveError).toBe(null)
    })

    it('displays error message in UI when save fails', async () => {
      const vm = wrapper.vm

      designsAPI.create.mockRejectedValue({
        response: { data: { detail: 'Validation error' } }
      })

      vm.title = 'Test'
      await vm.saveDesign()
      await nextTick()

      const errorMsg = wrapper.find('.error-message')
      expect(errorMsg.exists()).toBe(true)
      expect(errorMsg.text()).toBe('Validation error')
    })
  })

  /**
   * SECTION 9: Clear Grid (5 tests)
   */
  describe('Clear Grid', () => {
    it('renders clear button', () => {
      const clearBtn = wrapper.findAll('button').find(btn => btn.text().includes('Clear All'))
      expect(clearBtn.exists()).toBe(true)
    })

    it('shows confirmation dialog when clearing', async () => {
      const confirmSpy = vi.spyOn(window, 'confirm').mockReturnValue(false)

      const clearBtn = wrapper.findAll('button').find(btn => btn.text().includes('Clear All'))
      await clearBtn.trigger('click')

      expect(confirmSpy).toHaveBeenCalledWith('Clear the entire grid?')
    })

    it('clears grid when confirmed', async () => {
      const vm = wrapper.vm
      vi.spyOn(window, 'confirm').mockReturnValue(true)

      // Add some content
      vm.grid[0][0] = '#FF0000'
      vm.grid[5][5] = '#00FF00'

      vm.clearGrid()
      await nextTick()

      // All cells should be transparent
      expect(vm.grid[0][0]).toBe(TRANSPARENT)
      expect(vm.grid[5][5]).toBe(TRANSPARENT)
    })

    it('does not clear grid when cancelled', async () => {
      const vm = wrapper.vm
      vi.spyOn(window, 'confirm').mockReturnValue(false)

      // Add some content
      vm.grid[0][0] = '#FF0000'

      vm.clearGrid()
      await nextTick()

      // Content should remain
      expect(vm.grid[0][0]).toBe('#FF0000')
    })

    it('captures state before clearing when confirmed', async () => {
      const vm = wrapper.vm
      vi.spyOn(window, 'confirm').mockReturnValue(true)

      const historyLengthBefore = vm.history.length

      vm.clearGrid()
      await nextTick()

      expect(vm.history.length).toBe(historyLengthBefore + 1)
    })
  })
})
